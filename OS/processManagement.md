## 프로세스 생성
부모 프로세스가 자식 프로세스를 생성한다.<br/>
복제하는 방식으로 생성
- 자식은 부모의 공간을 복사 (binary and OS data)
- 자식은 그 공간에 새로운 프로그램을 올림
<br/>
<br/>

```
fork() // 시스템 콜이 새로운 프로세스를 생성
// - 부모를 그대로 복사(OS data except PID + binary)
// - 주소 공간 할당

exec() // 시스템 콜을 통해 새로운 프로그램을 메모리에 올림

exit() // 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌
// - 자식이 부모에게 output data를 보냄 (via wait) <- 무조건 자식이 부모보다 먼저 종료되어야 함
// - 프로세스의 각종 자원들이 운영체제에게 반납됨

abort() // 부모 프로세스가 자식의 수행을 종료시킴
// - 자식이 할당 자원의 한계치를 넘어섬
// - 자식에게 할당된 테스크가 더 필요하지 않음
// - 부모가 exit 하는 경우 -> 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다, 단계적인 종료
```
<br/>
원칙적으로 서로 자원을 공유하지 않는다.<br/>
자식 프로세스가 부모 프로세스를 그대로 copy하기 때문에 메모리에 두개의 복사본이 올라간다. 즉 메모리의 낭비가 일어난다.<br/>
리눅스 같은 효율적인 운영체제는 copy하지 않고 자식이 부모의 기존 내용을 공유한다.<br/>
그리고 어느정도 일을 하면서 각자의 길을 가게 되면 그제서야 부모에 공유하던 메모리공간 일부를 copy해서 가지게 된다. **COW기법**(copy on write) <br/>
즉, 일단 공유하다가 write가 일어나면 그 부분을 copy하여 자식 프로세스에서 관리하는 것이다.<br/>
<br/>
프로세스가 실행 될 때 부모와 자식이 공존하면서 수행되는 모델이 있고<br/>
자식이 종료될 때 까지 부모가 기다리는 모델이 있다.<br/>
<br/>

## fork() 시스템콜

다음과 같이 사용된다. <br>

```
int main()
{
    int pid;
    pid = fork(); // 자식프로세스는 fork를 실행한 이후 시점부터 실행되게 된다. -> 부모의 PC가 여기를 가르키고 있기 떄문
    if (pid == 0) // 자식 프로세스
        printf("I'm child\n");
    else if (pid > 0) // 부모 프로세스
        printf("I'm parent\n");
}
```
<br/>

## exec() 시스템콜

하지만 위와 같은 방식이면 같은 코드를 가진 프로세스들만 존재하게 된다.<br>
그래서 존재하는 시스템콜이 exec() 시스템콜이다.<br>
어떤 프로세스가 완전히 새롭게 태어날 수 있게 하는 역할을 한다.<br>

```
int main()
{
    int pid;
    pid = fork();
    if (pid == 0)
    {
        printf("I'm child\n");
        execlp("/bin/date", "/bin/date", (char *)0); // 자식은 date라는 프로그램으로 덮어 씌워진다. 한번 exec 하면 되돌아올 수 없다.
    }
    else if (pid > 0)
        printf("I'm parent\n");
}
```

## wait() 시스템콜

wait 시스템콜은 프로세스를 **child가 종료될때 까지** Block 상태로 잠들게하는 시스템콜 함수이다.<br>

```
int main()
{
    int childPID;

    //...

    childPID = fork()
    if (childPID == 0)
    {
        //...
    }
    else
    {
        wait();
    }

    // ... <-  이 코드는 자식이 종료된 후에, 즉 wait가 끝난 후에 실행된다.
}
```

## exit() 시스템콜

프로세스를 종료시킨다.<br>

### 자발적 종료
- 보통 컴파일러가 마지막 statement 수행 후에 자동으로 exit() 코드를 넣어준다.<br>

### 비자발적 종료
- 부모 프로세스가 자식 프로세스를 강제 종료
  - 자식 프로세스가 한계치를 넘어서는 자원 요청
  - 자식에게 할당된 테스크가 더 이상 필요하지 않음
- 키보드로 kill, break 등을 친 경우
- 부모가 종료하는 경우
  - 부모 프로세스가 종료되기 전에 자식들을 다 종료시킨 후 종료됨



## 프로세스 간 협력

### 독립적 프로세스
- 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함

### 협력 프로세스
- 프로세스 협력 매커니즘을 통해 하나의 프로세스가 다른 ㄴ프로세스의 수행에 영향을 미칠 수 있음

### 프로세스 간 협력 매커니즘 (IPC: Interprocess Communication)
- 메세지를 전달하는 방법
  - message passing : 커널을 통해 메세지 전달
- 주소 공간을 공유하는 방법
  - shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 매커니즘이 있음
  - thread: thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보는 것은 어렵지만, 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능

## Message Passing
프로세스 간에 공유 변수가 없기 때문에 다른 프로세스에게 정보 전달할 때는 메세지를 보낸다.
**직접 보낼 수는 없고 OS 커널을 이용해야 한다.**
 
 - Direct Communication
    - 통신하려는 프로세스의 이름을 명시적으로 표시
    - <img width="343" alt="스크린샷 2022-08-23 오전 11 20 54" src="https://user-images.githubusercontent.com/53016167/186054657-04713ad7-b0ae-4d48-afb5-774c5cb078e7.png">

 - Indirect Communication
   - mailbox 또는 port를 이용하여 메세지를 간접 전달
   - <img width="450" alt="스크린샷 2022-08-23 오전 11 21 09" src="https://user-images.githubusercontent.com/53016167/186054689-b369115c-74a1-405a-9caf-7f93dc77512a.png">


## Shared Memory

일부 메모리 주소 공간을 공유하는 것이 shared Memory 매커니즘이다.<br>
원칙적으로 프로세스는 코드, 데이터, 스택 등 독자적인 주소 공간을 가지고 있기 때문에, 자기 주소 공간만 접근할 수 있는데,<br>
shared Memory는 일부 주소공간을 두 프로세스가 공유할 수 있게 하는 것이다.<br>
<img width="248" alt="스크린샷 2022-08-23 오전 11 26 32" src="https://user-images.githubusercontent.com/53016167/186055315-d516ccc1-1c84-4494-8859-022d3d3bd401.png">


## thread
스레드는 하나의 프로세스 안에 CPU 수행 단위가 여러개 있는 것이기 떄문에, 프로세스 간의 공유는 아니다<br>
thread 간의 자원 공유는 매우 쉽다.<br>
주소 공간이 애초에 공유되어있기 때문<br>
